import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import fs from "fs";
import path from "path";

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === "production");

// 读取构建配置
function loadBuildConfig() {
	let buildConfig = {
		outputDir: "./dist",
		filesToCopy: ["main.js", "manifest.json", "styles.css"]
	}
	try {
		const configPath = path.join(process.cwd(), "build-config.json");
		if (fs.existsSync(configPath)) {
			const config = JSON.parse(fs.readFileSync(configPath, "utf8"));
			buildConfig.outputDir = config.outputDir || "./dist";
			buildConfig.filesToCopy = config.filesToCopy || ["main.js", "manifest.json", "styles.css"];
		}
	} catch (error) {
		console.warn("Warning: Could not load build-config.json, using defaults");
	}
	
	return buildConfig;
}

// 复制文件的函数
function watchAndCopyFiles() {
	const config = loadBuildConfig();
	const outputDir = config.outputDir;
	
	// 确保目标目录存在
	if (!fs.existsSync(outputDir)) {
		fs.mkdirSync(outputDir, { recursive: true });
		console.log(`Created output directory: ${outputDir}`);
	}
	
	// 复制指定文件
	config.filesToCopy.forEach(fileName => {
		const sourcePath = path.join(process.cwd(), fileName);
		const targetPath = path.isAbsolute(outputDir) 
			? path.join(outputDir, fileName)
			: path.join(process.cwd(), outputDir, fileName);
		
		if (!fs.existsSync(sourcePath)) {
			console.warn(`Warning: Source file ${fileName} not found`);
			return;
		}
        
        // 每个文件独立的防抖定时器
        let copyTimer = null;
        
        fs.watch(sourcePath, (eventType) => {
            if (eventType === 'change') {
                // 清除之前的定时器
                if (copyTimer) {
                    clearTimeout(copyTimer);
                }
                
                // 设置新的定时器，500ms后执行复制
                copyTimer = setTimeout(() => {
                    console.log(`File ${fileName} changed, copying...`);
                    fs.copyFileSync(sourcePath, targetPath);
                    console.log(`Copied ${fileName} to ${outputDir}/`);
                    copyTimer = null;
                }, 500);
            }
        });
	});
}

function copyFiles() {
	const config = loadBuildConfig();
	const outputDir = config.outputDir;
    if (!fs.existsSync(outputDir)) {
		fs.mkdirSync(outputDir, { recursive: true });
		console.log(`Created output directory: ${outputDir}`);
	}
	config.filesToCopy.forEach(fileName => {
		const sourcePath = path.join(process.cwd(), fileName);
		const targetPath = path.isAbsolute(outputDir) 
			? path.join(outputDir, fileName)
			: path.join(process.cwd(), outputDir, fileName);
        if (!fs.existsSync(sourcePath)) {
            console.warn(`Warning: Source file ${fileName} not found`);
            return;
        }
		fs.copyFileSync(sourcePath, targetPath);
		console.log(`Copied ${fileName} to ${outputDir}/`);
	});
}

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ["src/main.ts"],
	bundle: true,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins],
	format: "cjs",
	target: "es2018",
	logLevel: prod ? "warning" : "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	outfile: "main.js",
	minify: prod,
	jsx: "automatic",
	jsxImportSource: "react",
	// 添加别名配置
	alias: {
		"node:process": "process",
		"node:stream": "stream-browserify",
		"node:util": "util",
		"node:buffer": "buffer"
	},
	// 添加全局变量定义
	define: {
		"process.env.NODE_ENV": prod ? '"production"' : '"development"',
		"global": "globalThis",
		"process": "process",
		"Buffer": "Buffer"
	}
});

if (prod) {
	await context.rebuild();
	copyFiles();
	process.exit(0);
} else {
	// 开发模式：初始构建
	await context.rebuild();
	copyFiles();
	
	// 启动监听模式，每次构建完成后复制文件
	await context.watch();
    watchAndCopyFiles();
}
